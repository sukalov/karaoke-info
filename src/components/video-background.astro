<div class="loading-screen overflow-x-hidden" id="loadingScreen">
  <div class="container">
    <ul class="loader">
      <li></li><li></li><li></li><li></li><li></li><li></li>
    </ul>
  </div>
</div>

<div class="video-fallback" id="videoFallback">
  <img
    src="/barka-fallback.jpg"
    alt="Живое караоке в рюмочной 'Барка'"
    class="fallback-image"
  />
</div>

<video
  class="video-background overflow-x-hidden"
  id="bgVideo"
  autoplay
  muted
  loop
  playsinline
  preload="auto"
  title='Живое караоке в "Барке"'
  aria-label='Живое караоке в рюмочной "Барка", Гостинный двор, Москва, 2024'
>
  <source
    src="https://f003.backblazeb2.com/file/mkeverything/barka-360.mp4"
    type="video/mp4"
    data-quality="360p"
  />
  <source
    src="https://f003.backblazeb2.com/file/mkeverything/barka-compressed.mp4"
    type="video/mp4"
    data-quality="uncompressed"
    data-high-quality="true"
  />
  Ваш браузер не поддерживает video тег.
</video>

<script>
  // Type declarations for network APIs
  declare global {
    interface Navigator {
      connection?: {
        effectiveType: string;
        downlink: number;
        addEventListener: (type: string, listener: () => void) => void;
      };
    }
  }

  const video = document.getElementById("bgVideo") as HTMLVideoElement;
  const loadingScreen = document.getElementById("loadingScreen");
  const videoFallback = document.getElementById("videoFallback") as HTMLElement;

  // Performance tracking
  let loadStartTime = performance.now();
  let loadTimeout: NodeJS.Timeout | null = null;
  let retryCount = 0;
  const maxRetries = 3;

  // Speed measurement state
  let speedMeasurementStarted = false;
  let speedMeasurementComplete = false;
  let measuredDownloadSpeed = 0;
  let measurementStartTime = 0;
  let measurementStartBytes = 0;
  let highQualityPreloadStarted = false;
  let highQualityVideoLoaded = false;

  // Video file sizes (in bytes) for speed calculation
  const VIDEO_SIZES = {
    "360p": 10 * 1024 * 1024, // ~10MB
    uncompressed: 37 * 1024 * 1024, // ~37MB
  };

  // Disable body scrolling during video load
  document.body.style.overflow = "hidden";

  // Hide fallback image initially
  if (videoFallback) {
    videoFallback.style.display = "none";
  }

  function handleVideoLoaded() {
    const loadTime = performance.now() - loadStartTime;
    console.log(
      `Video loaded in ${Math.round(loadTime)}ms after ${retryCount} retries`,
    );

    video.classList.add("loaded");
    if (loadingScreen) {
      loadingScreen.classList.add("hidden");
    }

    // Hide fallback image
    if (videoFallback) {
      videoFallback.style.display = "none";
    }

    // Clear timeout if video loads successfully
    if (loadTimeout) {
      clearTimeout(loadTimeout);
      loadTimeout = null;
    }

    // Enable scrolling
    document.body.style.overflow = "auto";

    // Start speed measurement and high quality preload after initial load
    setTimeout(() => {
      startSpeedMeasurement();
      preloadHighQualityVideo();
    }, 500);
  }

  function handleVideoError() {
    console.warn(`Video load failed, attempt ${retryCount + 1}/${maxRetries}`);

    if (retryCount < maxRetries) {
      retryCount++;
      // Retry with exponential backoff
      const retryDelay = Math.min(1000 * Math.pow(2, retryCount), 5000);
      setTimeout(() => {
        video.load();
      }, retryDelay);
    } else {
      // Show fallback after all retries fail
      showFallback();
    }
  }

  function showFallback() {
    console.log("Showing fallback image due to video load failure");
    if (loadingScreen) {
      loadingScreen.classList.add("hidden");
    }

    if (videoFallback) {
      videoFallback.style.display = "block";
    }

    document.body.style.overflow = "auto";
  }

  // Hybrid speed measurement: Network API + Video loading
  function startSpeedMeasurement() {
    if (speedMeasurementStarted || speedMeasurementComplete) return;

    speedMeasurementStarted = true;
    console.log("Starting hybrid speed measurement...");

    // Phase 1: Check Network Information API immediately
    const connection = navigator.connection;
    let networkSpeedHint = 0;

    if (connection) {
      const { effectiveType, downlink } = connection;
      console.log(`Network API: ${effectiveType}, ${downlink} Mbps`);

      // Convert downlink (Mbps) to MB/s for comparison
      networkSpeedHint = downlink ? downlink / 8 : 0;

      // Log network info for debugging
      if (effectiveType === "slow-2g" || effectiveType === "2g") {
        console.log(
          "Slow network detected, but will still attempt high quality preload",
        );
      } else if (effectiveType === "4g" && downlink > 10) {
        console.log("Fast 4G detected");
      }
    }

    // Phase 2: Measure actual video loading speed
    measurementStartTime = performance.now();
    measurementStartBytes = getLoadedBytes();

    // Set up progress listener for 3 seconds
    const measureDuration = 3000; // 3 seconds

    const progressHandler = () => {
      if (speedMeasurementComplete) return;

      const currentTime = performance.now();
      const elapsed = (currentTime - measurementStartTime) / 1000; // seconds

      if (elapsed >= 0.5) {
        // Measure for at least 0.5s to get meaningful data
        const currentBytes = getLoadedBytes();
        const bytesLoaded = currentBytes - measurementStartBytes;

        if (bytesLoaded > 0) {
          measuredDownloadSpeed = bytesLoaded / elapsed / (1024 * 1024); // MB/s
          console.log(
            `Measured speed: ${measuredDownloadSpeed.toFixed(2)} MB/s (${elapsed.toFixed(1)}s)`,
          );
        }
      }
    };

    video.addEventListener("progress", progressHandler);

    // Complete measurement after 3 seconds
    setTimeout(() => {
      video.removeEventListener("progress", progressHandler);
      speedMeasurementComplete = true;

      // Calculate final speed
      const finalTime = performance.now();
      const finalElapsed = (finalTime - measurementStartTime) / 1000;
      const finalBytes = getLoadedBytes();
      const totalBytesLoaded = finalBytes - measurementStartBytes;

      if (totalBytesLoaded > 0 && finalElapsed > 0) {
        measuredDownloadSpeed = totalBytesLoaded / finalElapsed / (1024 * 1024);
      }

      console.log(
        `Speed measurement complete: ${measuredDownloadSpeed.toFixed(2)} MB/s`,
      );

      // Speed measurement is now for logging only
      // Switch happens automatically when high quality video loads
      // If high quality already loaded before measurement completed,
      // the switch already happened in the canplaythrough handler
      if (highQualityVideoLoaded) {
        console.log("High quality already loaded and switched");
      } else {
        console.log("High quality still loading, will switch when ready");
      }
    }, measureDuration);
  }

  function getLoadedBytes(): number {
    if (video.buffered.length === 0) return 0;

    // Get the end of the buffered range (most data loaded)
    const bufferedEnd = video.buffered.end(video.buffered.length - 1);

    // Estimate bytes based on video duration and buffered percentage
    // This is approximate but sufficient for speed comparison
    if (video.duration && video.duration > 0) {
      const bufferedRatio = bufferedEnd / video.duration;
      return Math.floor(VIDEO_SIZES["360p"] * bufferedRatio);
    }

    return 0;
  }

  function preloadHighQualityVideo() {
    if (highQualityPreloadStarted) return;

    console.log("Preloading high quality video in background...");
    highQualityPreloadStarted = true;

    const highQualitySource = video.querySelector(
      'source[data-high-quality="true"]',
    ) as HTMLSourceElement;

    if (!highQualitySource) {
      console.warn("High quality source not found");
      return;
    }

    // Create hidden video element for preloading
    const preloadVideo = document.createElement("video");
    preloadVideo.muted = true;
    preloadVideo.preload = "auto";
    preloadVideo.src = highQualitySource.src;
    preloadVideo.style.display = "none";
    document.body.appendChild(preloadVideo);

    preloadVideo.addEventListener(
      "canplaythrough",
      () => {
        console.log("High quality video preloaded and ready - switching now");
        highQualityVideoLoaded = true;

        // Always switch to high quality when it's loaded
        // The download already succeeded, so bandwidth is sufficient
        switchToHighQuality();

        // Clean up preload element
        document.body.removeChild(preloadVideo);
      },
      { once: true },
    );

    preloadVideo.addEventListener(
      "error",
      () => {
        console.warn("High quality video failed to preload");
        document.body.removeChild(preloadVideo);
      },
      { once: true },
    );

    // Start preloading
    preloadVideo.load();
  }

  function switchToHighQuality() {
    if (!highQualityVideoLoaded) return;

    console.log("Switching to high quality video...");

    const highQualitySource = video.querySelector(
      'source[data-high-quality="true"]',
    ) as HTMLSourceElement;

    if (!highQualitySource) return;

    // Store current state
    const currentTime = video.currentTime;
    const wasPlaying = !video.paused;
    const currentVolume = video.volume;

    // Seamless switch
    const performSwitch = async () => {
      try {
        video.pause();
        video.src = highQualitySource.src;

        // Wait for video to be ready
        await new Promise<void>((resolve) => {
          if (video.readyState >= 4) {
            resolve();
          } else {
            video.addEventListener("loadeddata", () => resolve(), {
              once: true,
            });
          }
        });

        // Restore playback state
        video.currentTime = Math.min(currentTime, video.duration - 0.5);
        video.volume = currentVolume;

        // Resume playback
        if (wasPlaying) {
          const playPromise = video.play();
          if (playPromise !== undefined) {
            playPromise.catch((err) =>
              console.log("Auto-play prevented after upgrade:", err),
            );
          }
        }

        console.log("Successfully upgraded to high quality video");
      } catch (error) {
        console.error("Error during video switch:", error);
      }
    };

    performSwitch();
  }

  // Setup timeout mechanism
  loadTimeout = setTimeout(() => {
    console.warn("Video load timeout (10 seconds), showing fallback");
    showFallback();
  }, 10000);

  // Setup event listeners
  if (video.readyState >= 3) {
    handleVideoLoaded();
  } else {
    video.addEventListener("canplay", handleVideoLoaded, { once: true });
    video.addEventListener("error", handleVideoError, { once: true });
  }

  // Intersection Observer for performance optimization
  if ("IntersectionObserver" in window) {
    const observer = new IntersectionObserver(
      (entries) => {
        entries.forEach((entry) => {
          if (entry.isIntersecting) {
            // Video is visible, ensure it's playing
            if (video.paused) {
              video.play().catch((err) => {
                console.log("Auto-play prevented:", err);
              });
            }
          } else {
            // Video is not visible, pause to save bandwidth
            if (!video.paused) {
              video.pause();
            }
          }
        });
      },
      { threshold: 0.1 },
    );

    observer.observe(video);
  }

  // Network change handling
  const connection = navigator.connection;
  if (connection) {
    connection.addEventListener("change", () => {
      console.log(
        `Network changed: ${connection.effectiveType} ${connection.downlink}Mbps`,
      );

      if (
        connection.effectiveType === "slow-2g" ||
        connection.effectiveType === "2g"
      ) {
        // Don't switch to high quality on slow networks
        console.log("Slow network detected, staying with current quality");
      }
    });
  }
</script>
<style>
  .video-background {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: -1;
    object-fit: cover;
    opacity: 0;
    transition: opacity 0.5s ease-in-out;
  }

  .video-fallback {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: -1;
    display: none;
  }

  .fallback-image {
    width: 100%;
    height: 100%;
    object-fit: cover;
    object-position: center;
  }

  .video-background.loaded {
    opacity: 1;
  }

  .loading-screen {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: var(--color-background);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 1000;
    transition: opacity 0.5s ease-in-out;
  }

  .loading-screen.hidden {
    opacity: 0;
    pointer-events: none;
  }

  .container {
    z-index: 4;
    margin: 0 auto;
    left: 35px;
    right: 0;
    top: 50%;
    margin-top: -45px;
    width: 130px;
    height: 80px;
    list-style: none;
    border: 2px solid rgba(255, 255, 255, 0.4);
    border-radius: 40px;
  }
  .loader {
    position: fixed;
    z-index: 3;
    margin: 0 auto;
    left: 5px;
    right: 0;
    top: 50%;
    margin-top: -48px;
    width: 90px;
    height: 60px;
    list-style: none;
  }

  @keyframes loadbars {
    0% {
      height: 10px;
      margin-top: 25px;
    }
    50% {
      height: 50px;
      margin-top: 0px;
    }
    100% {
      height: 10px;
      margin-top: 25px;
    }
  }

  li {
    background-color: var(--color-secondary);
    width: 10px;
    height: 10px;
    float: right;
    margin-right: 5px;
    box-shadow: 0px 20px 10px rgba(0, 0, 0, 0.2);
  }

  li:first-child {
    animation: loadbars 1s cubic-bezier(0.645, 0.045, 0.355, 1) infinite;
  }

  li:nth-child(2) {
    animation: loadbars 1s ease-in-out infinite;
    animation-delay: -0.2s;
  }

  li:nth-child(3) {
    animation: loadbars 1s ease-in-out infinite;
    animation-delay: -0.4s;
  }

  li:nth-child(4) {
    animation: loadbars 1s ease-in-out infinite;
    animation-delay: -0.6s;
  }

  li:nth-child(5) {
    animation: loadbars 1s ease-in-out infinite;
    animation-delay: -0.8s;
  }

  li:nth-child(6) {
    animation: loadbars 1s ease-in-out infinite;
    animation-delay: -1s;
  }
</style>
